/**
 * Created by veselink1.
 * Released under the MIT license.
 */

#ifndef REFL_HT_ENGINE_HPP
#define REFL_HT_ENGINE_HPP
#include <cstring>
#include <fstream>
#include <clang-c/Index.h>
#include "rht-core.hpp"
#include "rht-util.hpp"
#include "rht-fs.hpp"

namespace rht::engine
{

static constexpr char log_info[] = "Info: ";
static constexpr char log_error[] = "Error: ";

static constexpr char macro_name[] = "$refl";
static constexpr char marker_name[] = "__refl_autogenerated_marker__";

void dbg_print_cursor(CXCursor cursor, const char *msg = "")
{
    std::cout << log_info << msg << " '" << clang_getCursorDisplayName(cursor) << "' of type '"
              << clang_getCursorKindSpelling(clang_getCursorKind(cursor)) << "'\n";
}

void move_to(std::ifstream &fs, unsigned line, unsigned column)
{
    fs.clear();
    fs.seekg(0, std::ios::beg);

    std::string ignore;
    for (unsigned i = 1; i < line; i++)
    {
        std::getline(fs, ignore);
    }
    fs.seekg(column - 1, std::ios::cur);
}

template <typename FwdIt>
size_t seek_closing_parens(FwdIt begin, FwdIt end)
{
    int length = 0;
    int pending = 0;
    for (; begin != end; ++begin)
    {
        length++;
        if (*begin == '(')
            pending++;
        else if (*begin == ')')
            pending--;

        if (pending == -1)
            return length;
    }
    return -1;
}

std::string extract_macro_args(std::ifstream &fs, CXCursor cursor)
{
    auto loc = util::get_source_location(cursor);
    auto offset = util::array_size(macro_name); // includes terminating \0, takes care of (
    move_to(fs, loc.line, loc.column + offset);

    auto begin = fs.tellg();
    auto length = seek_closing_parens(std::istreambuf_iterator<char>(fs), std::istreambuf_iterator<char>());
    fs.seekg(begin, std::ios::beg);

    std::string args(length - 1, '\0');
    fs.get(args.data(), length);

    return args;
}

std::vector<core::TypeInfo> process_translation_unit(CXTranslationUnit unit)
{
    CXCursor cursor = clang_getTranslationUnitCursor(unit);

    std::string filename;
    util::visit_children(cursor, [&](CXCursor child, CXCursor parent) -> CXChildVisitResult {
        filename = util::get_source_location(child).filename;
        return CXChildVisit_Break;
    });

    std::ifstream file(filename, std::ios::in);

    std::optional<std::string> pending_macro_args;
    std::vector<core::TypeInfo> types;

    util::visit_children(cursor, [&](CXCursor child, CXCursor parent) -> CXChildVisitResult {
        if (pending_macro_args)
        {
            auto macro_args = *pending_macro_args;
            pending_macro_args.reset();

            switch (clang_getCursorKind(child))
            {
            case CXCursor_StructDecl:
            case CXCursor_ClassDecl:
            {
                types.push_back(core::TypeInfo(util::get_full_name(child), macro_args));
                break;
            }
            case CXCursor_FieldDecl:
            case CXCursor_CXXMethod:
            {
                auto name = clang_getCString(clang_getCursorDisplayName(child));
                auto parent_name = util::get_full_name(clang_getCursorSemanticParent(child));
                if (types.empty() || parent_name != types.back().Name)
                {
                    types.push_back(core::TypeInfo(parent_name, ""));
                }

                auto member_type = clang_getCursorKind(child) == CXCursor_FieldDecl ? core::MemberType::Field : core::MemberType::Function;
                auto &type = types.back();
                type.Members.push_back(core::MemberInfo(member_type, name, macro_args));
                break;
            }
            default:
                std::cout << log_error << "Unsupported item type for reflection '"
                          << clang_getCursorKindSpelling(clang_getCursorKind(child))
                          << "'! Terminating application!\n";
                std::exit(-1);
                break;
            }
        }

        switch (clang_getCursorKind(child))
        {
        case CXCursor_Namespace:
        case CXCursor_StructDecl:
        case CXCursor_ClassDecl:
            return CXChildVisit_Recurse;
        case CXCursor_TypedefDecl:
            if (std::strcmp(clang_getCString(clang_getCursorDisplayName(child)), marker_name) == 0)
            {
                pending_macro_args = extract_macro_args(file, child);
            }
            return CXChildVisit_Continue;
        default:
            return CXChildVisit_Continue;
        }
    });

    return types;
}

std::stringstream generate_metadata_source(const std::vector<core::TypeInfo> &types)
{
    std::stringstream ss;
    for (auto &&t : types)
    {
        ss << "REFL_TYPE(" << t.Name
           << (t.Attributes.empty() ? "" : ", " + t.Attributes) << ")\n";
        for (auto &&m : t.Members)
        {
            switch (m.Type)
            {
            case core::MemberType::Field:
                ss << "\tREFL_FIELD(";
                break;
            case core::MemberType::Function:
                ss << "\tREFL_FUNC(";
                break;
            }
            ss << m.Name << (m.Attributes.empty() ? "" : ", " + m.Attributes) << ")\n";
        }
        ss << "REFL_END\n\n";
    }

    return ss;
}

bool file_needs_processing(const char* filename)
{
    std::regex reflmd_include("#include\\s*\".+\\.reflmd\"");
    std::string input_contents = util::read_to_string(filename);
    // The file does not include any .reflmd files, 
    // therefore it doesn't need any preprocessing.
    return std::regex_search(input_contents, reflmd_include);
}

void process_file(const char *filename)
{
    static const char *const clang_args[] = {
        "-DREFL_PREPROCESSOR"};

    std::cout << "I: Processing " << filename << "...\n";

    CXIndex index = clang_createIndex(0, 0);
    CXTranslationUnit unit = clang_parseTranslationUnit(
        index,
        filename,
        clang_args,
        rht::util::array_size(clang_args),
        nullptr,
        0,
        CXTranslationUnit_None);

    if (unit == nullptr)
    {
        std::cerr << "Unable to parse translation unit. Quitting." << std::endl;
        std::exit(-1);
    }

    auto types = process_translation_unit(unit);
    auto source = generate_metadata_source(types);

    fs::path path(filename);
    auto md_filename = path.replace_extension(".reflmd");

    std::cout << "I: Opening " << md_filename << " for writing...\n";
    std::ofstream output_fs(md_filename);
    output_fs << source.str();
    std::cout << "I: Metadata written successfully to " << md_filename << "\n\n";

    clang_disposeTranslationUnit(unit);
    clang_disposeIndex(index);
}

} // namespace rht::engine

#endif // REFL_HT_ENGINE_HPP