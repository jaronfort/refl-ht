/**
 * Created by veselink1.
 * Released under the MIT license.
 */

#ifndef REFL_HT_ENGINE_HPP
#define REFL_HT_ENGINE_HPP
#include <cstring>
#include <fstream>
#include <ctime>
#include <clang-c/Index.h>
#include "rht-core.hpp"
#include "rht-util.hpp"
#include "rht-fs.hpp"

namespace rht::engine
{

static constexpr char macro_name[] = "REFL";
static constexpr char include_macro_name[] = "REFL_METADATA_FILE";

static constexpr char type_macro_name[] = "REFL_TYPE";
static constexpr char function_macro_name[] = "REFL_FUNCTION";
static constexpr char field_macro_name[] = "REFL_FIELD";
static constexpr char end_macro_name[] = "REFL_END";

static constexpr char metadata_folder_name[] = "reflmd";
static constexpr char marker_name[] = "__refl_autogenerated_marker__";

void dbg_print_cursor(CXCursor cursor, const char *msg = "")
{
    util::log_info() << msg << " '" << clang_getCursorDisplayName(cursor) << "' of type '"
                     << clang_getCursorKindSpelling(clang_getCursorKind(cursor)) << "'\n";
}

void move_to(std::ifstream& fs, unsigned line, unsigned column)
{
    fs.clear();
    fs.seekg(0, std::ios::beg);

    std::string ignore;
    for (unsigned i = 1; i < line; i++)
    {
        std::getline(fs, ignore);
    }
    fs.seekg(column - 1, std::ios::cur);
}

template <typename FwdIt>
size_t seek_closing_parens(FwdIt begin, FwdIt end)
{
    int offset = 0;
    int pending = 0;
    for (; begin != end; ++begin)
    {
        offset++;
        if (*begin == '(')
            pending++;
        else if (*begin == ')')
            pending--;

        if (pending == -1)
            return offset;
    }
    return std::string::npos;
}

std::string extract_macro_args(std::ifstream& fs, CXCursor cursor)
{
    auto loc = util::get_source_location(cursor);
    auto name_offset = util::array_size(macro_name); // includes terminating \0, takes care of (
    move_to(fs, loc.line, loc.column + name_offset);

    auto begin = fs.tellg();
    auto offset = seek_closing_parens(std::istreambuf_iterator<char>(fs), std::istreambuf_iterator<char>());
    if (offset == std::string::npos)
    {
        auto loc = util::get_source_location(cursor);

        std::stringstream ss;
        ss << "Expected to find ) after '" << macro_name << "(' at " << loc << "! Terminating application!\n";
        throw std::runtime_error(ss.str());
    }

    fs.seekg(begin, std::ios::beg);

    std::string args(offset - 1, '\0');
    fs.get(args.data(), offset);

    return args;
}

std::vector<core::ModuleInfo> process_translation_unit(CXTranslationUnit unit, const char *filename)
{
    CXCursor cursor = clang_getTranslationUnitCursor(unit);

    std::unordered_map<std::string, std::ifstream> open_files{};
    std::unordered_map<std::string, core::ModuleInfo> modules{};

    std::optional<std::string> pending_macro_args;

    util::visit_children(cursor, [&](CXCursor child, CXCursor parent) -> CXChildVisitResult {
        if (pending_macro_args)
        {
            auto location = util::get_source_location(child);
            auto& module = modules.find(location.filename)->second;
            auto& types = module.Types;

            auto macro_args = *pending_macro_args;
            pending_macro_args.reset();

            switch (clang_getCursorKind(child))
            {
            case CXCursor_StructDecl:
            case CXCursor_ClassDecl:
            {
                types.push_back(core::TypeInfo(util::get_full_name(child), macro_args));
                break;
            }
            case CXCursor_FieldDecl:
            case CXCursor_CXXMethod:
            {
                auto name = clang_getCString(clang_getCursorDisplayName(child));
                auto parent_name = util::get_full_name(clang_getCursorSemanticParent(child));
                if (types.empty() || parent_name != types.back().Name)
                {
                    types.push_back(core::TypeInfo(parent_name, ""));
                }

                auto member_type = clang_getCursorKind(child) == CXCursor_FieldDecl ? core::MemberType::Field : core::MemberType::Function;
                auto& type = types.back();
                type.Members.push_back(core::MemberInfo(member_type, name, macro_args));
                break;
            }
            default:
                util::log_error() << "Unsupported item type for reflection '"
                                  << clang_getCursorKindSpelling(clang_getCursorKind(child))
                                  << "'! Terminating application!\n";
                std::exit(-1);
                break;
            }
        }

        switch (clang_getCursorKind(child))
        {
        case CXCursor_Namespace:
        case CXCursor_StructDecl:
        case CXCursor_ClassDecl:
            return CXChildVisit_Recurse;
        case CXCursor_TypedefDecl:
            if (std::strcmp(clang_getCString(clang_getCursorDisplayName(child)), marker_name) == 0)
            {
                auto source_filename = util::get_source_location(child).filename;

                auto source_filestream_it = open_files.find(source_filename);
                if (source_filestream_it == open_files.end())
                {
                    util::log_info() << "Adding " << fs::relative(source_filename) << " to module index...\n";
                    source_filestream_it = open_files.insert({source_filename, std::ifstream(source_filename, std::ios::in)}).first;
                }

                pending_macro_args = extract_macro_args(source_filestream_it->second, child);
                modules.insert({source_filename, core::ModuleInfo(source_filename, {})});
            }
        default:
            return CXChildVisit_Continue;
        }
    });

    std::vector<core::ModuleInfo> module_vec{};
    module_vec.reserve(modules.size());
    for (auto&& entry : modules)
    {
        module_vec.emplace_back(std::move(entry.second));
    }

    return module_vec;
}

std::stringstream generate_metadata_source(const std::vector<core::TypeInfo>& types)
{
    std::stringstream ss;
    for (auto&& t : types)
    {
        ss << type_macro_name << "(" << t.Name
           << (t.Attributes.empty() ? "" : ", " + t.Attributes) << ")\n";
        for (auto&& m : t.Members)
        {
            switch (m.Type)
            {
            case core::MemberType::Field:
                ss << "\t" << field_macro_name << "(";
                break;
            case core::MemberType::Function:
                ss << "\t" << function_macro_name << "(";
                break;
            }
            ss << m.Name << (m.Attributes.empty() ? "" : ", " + m.Attributes) << ")\n";
        }
        ss << end_macro_name << "\n\n";
    }

    return ss;
}

std::string generated_header()
{
    std::stringstream ss;
    auto time = std::time(nullptr);
    ss << "/* Autogenerated by refl-ht on " << std::put_time(std::localtime(&time), "%D at %T") << " */\n\n";
    return ss.str();
}

void process_module(const rht::core::ModuleInfo& module)
{
    using namespace std::string_literals;

    util::log_info() << "Processing module " << fs::relative(module.Path) << "...\n";
    auto source = generate_metadata_source(module.Types);

    const std::string& path = module.Path;

    auto input_source = util::read_to_string(path.c_str());
    std::ofstream input_fs(path.c_str());

    std::regex md_include_regex("#include\\s+"s + include_macro_name);
    std::regex md_define_regex("#define\\s+"s + include_macro_name + "\\s+\".+\"\\s*");
    std::string md_define("#define "s + include_macro_name + " \"" + metadata_folder_name + "/" + fs::filename(path) + "\"\n");

    if (std::regex_search(input_source, md_define_regex))
    {
        input_source = std::regex_replace(input_source, md_define_regex, md_define);
    }
    else
    {
        input_source = md_define + input_source;
    }

    input_fs << input_source;

    if (!std::regex_search(input_source, md_include_regex))
    {
        util::log_info() << "Missing an '#include " << include_macro_name << "' directive in " << fs::relative(path)
                         << ". It was added automatically at the end of the source file.\n";

        input_fs << "\n#include " << include_macro_name << "\n";
    }

    auto md_path = fs::concat(fs::parent_path(path), metadata_folder_name);
    fs::create_directory(md_path);

    auto md_filename = fs::concat(md_path, fs::filename(path));

    util::log_info() << "Opening " << fs::relative(md_filename) << " for writing...\n";
    std::ofstream output_fs(md_filename);
    output_fs << generated_header();
    output_fs << source.str();
    util::log_info() << "Metadata written successfully to " << fs::relative(md_filename) << "\n\n";
}

void process_file(const char *filename)
{
    static const char *const clang_args[] = {
        "-x",
        "c++",
        "-DREFL_PREPROCESSOR"};

    util::log_info() << "Parsing input file " << fs::relative(filename) << "...\n\n";

    CXIndex index = clang_createIndex(0, 0);
    CXTranslationUnit unit;

    CXErrorCode error = clang_parseTranslationUnit2(
        index,
        filename,
        clang_args,
        rht::util::array_size(clang_args),
        nullptr,
        0,
        CXTranslationUnit_None,
        &unit);

    if (unit == nullptr)
    {
        std::cerr << "Unable to parse translation unit. Error Code: " << error << ". Quitting." << std::endl;
        std::exit(-1);
    }

    auto modules = process_translation_unit(unit, filename);

    clang_disposeTranslationUnit(unit);
    clang_disposeIndex(index);

    for (auto&& module : modules)
    {
        try
        {
            process_module(module);
        }
        catch (const std::exception& e)
        {
            util::log_error() << "Processing module " << module.Path << " failed! " 
                + util::to_string(e) + "\n";
        }
    }
}

} // namespace rht::engine

#endif // REFL_HT_ENGINE_HPP